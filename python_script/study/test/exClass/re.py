#coding=utf-8
__author__ = 'Administrator'

import re
# re模块
s = r'ABC\-001'
print s

ss = re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
print ss

# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是:
test = '用户输入的字符串'
if re.match(r'正则表达式',test):
    print 'ok'
else:
    print 'failed'

# 切分字符串---------------------------------------------
# 用正则表达式切分字符串比用固定的字符更灵活
# 遇到空格无法有效切分
# 无法识别连续的空格，用正则表达式试试
sa1 = re.split(r'\s+','a   b              c')
print sa1

# 无论多少个空格都可以正常分割。加入,试试：
sa2 = re.split(r'[\s\,]+', 'a,b,  c   d')
print sa2

# 再加入;试试：
sa3 = re.split(r'[\s\,\;]+', 'a,b,  ;;c ;;  d')
print sa3

# 分组-------------------------------------------------
# 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。
# 用()表示的就是要提取的分组（Group）。

m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print m
print m.group(0)
print m.group(1)
print m.group(2)

t = '19:50:32'
mm = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print mm.groups()

# 贪婪匹配
# 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
st = re.match(r'^(\d+)(0*)$', '102300').groups()
print st

# 编译
# 当我们在Python中使用正则表达式时，re模块内部会干两件事情：
# 1、编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
# 2、用编译后的正则表达式去匹配字符串。
# 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，
# 接下来重复使用时就不需要编译这个步骤了，直接匹配：
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print re_telephone.match('010-12345').groups()